extern fn malloc(size: usize) -> &void;
extern fn realloc(ptr: &void, size: usize) -> &void;
extern fn free(ptr: &void);

@lang("allocator_trait")
trait Allocator {
    fn alloc(self: &Self, size: usize) -> &void;
    fn realloc(self: &Self, ptr: &void, size: usize) -> &void;
    fn free(self: &Self, ptr: &void);
}

struct CAlloc {;
    impl Allocator {
        fn alloc(self: &Self, size: usize) -> &void = malloc(size);
        fn realloc(self: &Self, ptr: &void, size: usize) -> &void = realloc(ptr, size);
        fn free(self: &Self, ptr: &void) = free(ptr);
    }
}
@lang("allocator")
let allocator: CAlloc = .{};

@lang("copy_trait")
trait Copy {}

@lang("clone_trait")
trait Clone {
    fn clone(self: &Self) -> Self;
}

@lang("printf")
@ext_vararg()
extern fn printf(pat: &u8);

@lang("eq_trait")
trait Eq {
    fn eq(self: &Self, other: &Self) -> bool;
}

@lang("neq_trait")
trait Neq {
    fn neq(self: &Self, other: &Self) -> bool;
}

struct Test2 {
    test: &Test
}

struct Test {
    value: i32
}

struct Nya {
    meow: i32,
    mreow: u32,
    boop: usize;

    fn new(meow: i32, mreow: u32, boop: usize) -> Nya = .{ meow: meow, mreow: mreow, boop: boop };
}

let meow: i32 = 12;
let meowmeow: &str = "fdkjghdafhgjkdsfg";

fn test() -> Nya = Nya::new(13, 14, 15);
fn test2() -> Nya = .{ meow: 13, mreow: 3948, boop: 0xff87cd };
fn test3(v: &Nya) -> &u32 = &v.mreow;
fn test4(v: [Nya; 5], idx: usize) -> Nya = v[idx];
fn test5(v: &[Nya]) -> usize = v[2].boop;

fn test6() -> &[&u8] = &[&3, &4];
fn test7(v: &[&[u8]], a: usize, b: usize) -> u8 = v[a][b];
fn test8() -> &str = "abcdefg :3";
//fn test9() -> i32 = woof(12);

extern fn main(argc: usize, argv: &&u8) -> i32 {
    let value = -12i32;
    let _value = &&value;
    let valuea = _value as &[&i32; 1];
    let valueb = *valuea[0];
    printf("%d\0" as &u8, valueb);
    return 0;
}

fn test10(v: fn(i32, i32) -> i32, a: i32, b: i32) -> i32 = v(a, b);
fn test11(lhs: i32, rhs: i32) -> i32 = lhs + rhs;
fn `lol this ident has a space in it`() -> i32 = 3456;

fn test12() -> (i32, i32) = .(1, 2);
fn test13() -> (i32, i32) = .[1, 2];

use "test"::woof;

export printf;
export malloc;
export free;
