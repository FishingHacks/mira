//! Panicking
//!
//! Module to panic during execution because something went very wrong

use pkg::print_u64_hex;
use pkg::cstrlen;
use pkg::os::write;
use pkg::os::exit;

struct unw_cursor { inner: [u64; 127] }
struct unw_context { inner: [u64; 121] }
let UNW_REG_IP: u32 = 16;

@alias("_Ux86_64_getcontext")
extern fn unw_getcontext(v: &unw_context);
@alias("_Ux86_64_init_local")
extern fn unw_init_local(cursor: &unw_cursor, v: &unw_context);
@alias("_Ux86_64_step")
extern fn unw_step(cursor: &unw_cursor) -> i32;
@alias("_Ux86_64_get_reg")
extern fn unw_get_reg(cursor: &unw_cursor, register: u32, value: &usize);
@alias("_Ux86_64_get_proc_name")
extern fn unw_get_proc_name(cursor: &unw_cursor, name: &u8, name_size: usize, offset: &usize) -> i32;

fn print_demangle_name(name: &str) -> bool {
    if (name.len() < 4) return false;
    // 69 == b'E'
    if ((name as &[u8])[name.len() - 1] != 69) return false;
    let inner = "";
    if (name.substr(0, 3).eq("_ZN")) inner = name.substr(3, name.len() - 4);
    else if (name.substr(0, 2).eq("ZN")) inner = name.substr(2, name.len() - 3);
    else if (name.substr(0, 4).eq("__ZN")) inner = name.substr(4, name.len() - 5);
    else return false;

    let len = 0usize;
    let bstr = inner as &[u8];
    let i = 0usize;
    let first = true;
    // '0': 48, '1': 57
    while(i < inner.len()) {
        let a = bstr[i] > 47;
        let b = bstr[i] < 58;
        if(a && b) {
            len = len * 10 + bstr[i] as usize - 48;
            i += 1;
        } else if (len == 0) return false;
        else {
            let s = inner.substr(i, len);
            if(!is_hash(s as &[u8], s.len())) {
                if(!first) "::".print();
                s.print();
                first = false;
            }
            i += len;
            len = 0;
        }
    }
    return true;
}

fn is_hash(b: &[u8], len: usize) -> bool {
    if (len < 2) return false;
    if (b[0] != 104) return false; // 'h'
    let i = 1usize;
    while (i < len) {
        // '0': 48, '1': 57
        let dig1 = b[i] > 47;
        let dig2 = b[i] < 58;
        let is_digit = dig1 && dig2;

        // 'a': 97, 'f': 102
        let alphanum1 = b[i] > 96;
        let alphanum2 = b[i] < 103;
        let is_alphanum = (alphanum1 && alphanum2) || is_digit;
        if(!is_alphanum) return false;
        i += 1;
    }
    return true;
}

/// Shows the current backtrace
pub fn show_bt() {
    let cursor = unw_cursor { inner: [0u64; 127] };
    let context = unw_context { inner: [0u64; 121] };
    let ip = 0usize;
    let offset = 0usize;

    unw_getcontext(&context);
    unw_init_local(&cursor, &context);
    let name_buf = [0u8; 4096];
    while (unw_step(&cursor) > 0) {
        unw_get_reg(&cursor, UNW_REG_IP, &ip);
        print_u64_hex(ip as u64);
        ": ".print();
        name_buf[0] = 0;
        if (unw_get_proc_name(&cursor, &name_buf as &[u8] as &u8, 4096, &offset) == 0) {
            "(".print();
            let len = cstrlen(&name_buf[0]);
            let s = pkg::intrinsics::with_metadata::<u8, str>(&name_buf[0], len);
            if (!print_demangle_name(s)) s.print();
            "+".print();
            print_u64_hex(offset as u64);
            ")".println();
        } else "-- no symbol name was found".println();
    }
}

/// Prints "panic: {message}\n", prints the backtrace and exits.
pub fn panic(message: &str) {
    "panic: ".print();
    message.println();
    "".println();
    show_bt();
    exit(110);
}
