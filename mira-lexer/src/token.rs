use mira_context::DocComment;
#[cfg(test)]
use mira_context::SharedCtx;
use mira_spans::interner::{ByteSymbol, SpanInterner};
use mira_spans::{Ident, Span, Symbol};
use std::alloc::Layout;
use std::fmt::{Debug, Display, Write};
use std::marker::PhantomData;
use std::ptr::NonNull;
use std::str::FromStr;

use crate::Lexer;

macro_rules! token_type {
    ($($(#[$($meta:tt)*])* $key:ident $(=$value:literal)?),* $(,)?) => {
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TokenType {
            $(
                $(#[$($meta)*])*
                $key
            ),*
        }

        impl TokenType {
            pub fn char_len(self) -> Option<u32> {
                self.as_str().map(|s| s.len() as u32)
            }

            pub fn as_str(self) -> Option<&'static str> {
                match self {
                    $(Self::$key => token_type!(!internal $($value)?),)*
                }
            }
        }
    };
    (!internal) => {
        None
    };
    (!internal $value:literal) => {
        Some($value)
    };
}

token_type! {
    Let = "let",
    EqualEqual = "==",
    NotEquals = "!=",
    LessThan = "<",
    GreaterThan = ">",
    Not = "!",
    LogicalAnd = "&&",
    LogicalOr = "||",
    StringLiteral,
    ByteStringLiteral,
    FloatLiteral,
    SIntLiteral,
    UIntLiteral,
    BooleanLiteral,
    MacroInvocation,
    MacroDef = "macro!",
    VoidLiteral = "void",
    IdentifierLiteral,
    Equal = "=",
    Colon = ":",
    Semicolon = ";",
    Plus = "+",
    Minus = "-",
    Asterix = "*",
    Divide = "/",
    Modulo = "%",
    Ampersand = "&",
    BitwiseOr = "|",
    BitwiseXor = "^",
    PipeOperator = "|>",
    Return = "return",
    Fn = "fn",
    Extern = "extern",
    Use = "use",
    Mod = "mod",
    If = "if",
    Else = "else",
    Asm = "asm",
    Defer = "defer",
    Volatile = "volatile",
    While = "while",
    For = "for",
    Pub = "pub",
    In = "in",
    Unsized = "unsized",
    Range = "..",
    RangeInclusive = "..=",
    ReturnType = "->",
    Struct = "struct",
    Trait = "trait",
    Impl = "impl",
    Comma = ",",
    PlusAssign = "+=",
    MinusAssign = "-=",
    Dot = ".",
    Dollar = "$",
    As = "as",
    AnnotationIntroducer = "@",
    NamespaceAccess = "::",
    QuestionMark = "?",
    DocComment = "<doc comment>",
    ModuleDocComment = "<module doc comment>",

    /// Not generated by the lexer -- use TokenTree::Delimited.
    ParenOpen = "(",

    /// Not generated by the lexer -- use TokenTree::Delimited.
    BracketOpen = "[",

    /// Not generated by the lexer -- use TokenTree::Delimited.
    CurlyOpen = "{",

    /// Not generated by the lexer -- use TokenTree::Delimited.
    ParenClose = ")",

    /// Not generated by the lexer -- use TokenTree::Delimited.
    BracketClose = "]",

    /// Not generated by the lexer -- use TokenTree::Delimited.
    CurlyClose = "}",
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Delimiter {
    /// `( ... )`
    Parenthesis,
    /// `[ ... ]`
    Brackets,
    /// `{ ... }`
    Curlies,
}

impl Delimiter {
    pub fn open_tok<'ctx>(self, span: Span<'ctx>) -> Token<'ctx> {
        Token {
            ty: self.open_tt(),
            literal: None,
            span,
        }
    }

    pub fn close_tok<'ctx>(self, span: Span<'ctx>) -> Token<'ctx> {
        Token {
            ty: self.close_tt(),
            literal: None,
            span,
        }
    }

    pub fn open_tt(self) -> TokenType {
        match self {
            Delimiter::Parenthesis => TokenType::ParenOpen,
            Delimiter::Brackets => TokenType::BracketOpen,
            Delimiter::Curlies => TokenType::CurlyOpen,
        }
    }

    pub fn close_tt(self) -> TokenType {
        match self {
            Delimiter::Parenthesis => TokenType::ParenClose,
            Delimiter::Brackets => TokenType::BracketClose,
            Delimiter::Curlies => TokenType::CurlyClose,
        }
    }
}

#[derive(Debug, Clone)]
pub struct TTDelim<'ctx> {
    pub open_span: Span<'ctx>,
    pub close_span: Span<'ctx>,
    pub children: Box<[TokenTree<'ctx>]>,
    pub delimiter: Delimiter,
}

impl<'ctx> TTDelim<'ctx> {
    pub fn open_tok(&self) -> Token<'ctx> {
        self.delimiter.open_tok(self.open_span)
    }

    pub fn close_tok(&self) -> Token<'ctx> {
        self.delimiter.close_tok(self.close_span)
    }

    pub fn full_span(&self, interner: &SpanInterner<'ctx>) -> Span<'ctx> {
        self.open_span.combine_with([self.close_span], interner)
    }
}

#[derive(Debug, Clone)]
pub enum TokenTree<'ctx> {
    Token(Token<'ctx>),
    Delimited(TTDelim<'ctx>),
}

impl<'ctx> TokenTree<'ctx> {
    pub fn token(&self) -> Option<&Token<'ctx>> {
        match self {
            TokenTree::Token(t) => Some(t),
            TokenTree::Delimited(_) => None,
        }
    }

    pub fn span(&self) -> Span<'ctx> {
        match self {
            TokenTree::Token(t) => t.span,
            TokenTree::Delimited(v) => v.open_span,
        }
    }

    /// Flattens the token tree into a list of tokens, replacing ( ... ) with [(, ..., )]
    pub fn flatten(mes: &[TokenTree<'ctx>]) -> Vec<Token<'ctx>> {
        let mut tokens = Vec::with_capacity(mes.len());
        mes.iter().for_each(|v| v.flatten_into(&mut tokens));
        tokens
    }

    /// Flattens the token tree into a list of tokens, replacing ( ... ) with [(, ..., )]
    pub fn flatten_into(&self, tokens: &mut Vec<Token<'ctx>>) {
        match self {
            &TokenTree::Token(t) => tokens.push(t),
            TokenTree::Delimited(v) => {
                tokens.push(v.open_tok());
                v.children.iter().for_each(|v| v.flatten_into(tokens));
                tokens.push(v.close_tok());
            }
        }
    }

    /// Returns the flattened length of the token tree
    pub fn flattened_len(mes: &[TokenTree<'ctx>]) -> usize {
        mes.iter().map(Self::flattened_len_single).sum()
    }

    /// Returns the flattened length of the token tree
    pub fn flattened_len_single(&self) -> usize {
        match self {
            TokenTree::Token(_) => 1,
            TokenTree::Delimited(v) => v.children.iter().map(Self::flattened_len_single).sum(),
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum NumberType {
    F32,
    F64,
    I8,
    I16,
    I32,
    I64,
    Isize,
    U8,
    U16,
    U32,
    U64,
    Usize,
    None,
}

impl Display for NumberType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::F32 => f.write_str("f32"),
            Self::F64 => f.write_str("f64"),
            Self::I8 => f.write_str("i8"),
            Self::I16 => f.write_str("i16"),
            Self::I32 => f.write_str("i32"),
            Self::I64 => f.write_str("i64"),
            Self::U8 => f.write_str("u8"),
            Self::U16 => f.write_str("u16"),
            Self::U32 => f.write_str("u32"),
            Self::U64 => f.write_str("u64"),
            Self::Usize => f.write_str("usize"),
            Self::Isize => f.write_str("isize"),
            Self::None => Ok(()),
        }
    }
}

impl FromStr for NumberType {
    type Err = ();

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "f32" => Ok(Self::F32),
            "f64" => Ok(Self::F64),
            "i8" => Ok(Self::I8),
            "i16" => Ok(Self::I16),
            "i32" => Ok(Self::I32),
            "i64" => Ok(Self::I64),
            "u8" => Ok(Self::U8),
            "u16" => Ok(Self::U16),
            "u32" => Ok(Self::U32),
            "u64" => Ok(Self::U64),
            "usize" => Ok(Self::Usize),
            "isize" => Ok(Self::Isize),
            _ => Err(()),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq)]
pub enum Literal<'arena> {
    Float(f64, NumberType),
    SInt(i64, NumberType),
    UInt(u64, NumberType),
    String(Symbol<'arena>),
    ByteString(ByteSymbol<'arena>),
    Bool(bool),
    DocComment(DocComment),
}

impl Literal<'_> {
    /// compares the two literals, treating Literal::String and Literal::DocComment as the same.
    #[cfg(test)]
    pub(super) fn doc_comment_as_symbol_eq(&self, other: &Literal<'_>, ctx: SharedCtx<'_>) -> bool {
        match self {
            Literal::String(symbol) => match other {
                Literal::String(other) => symbol == other,
                Literal::DocComment(other) => {
                    ctx.with_doc_comment(*other, |v| v == symbol.to_str())
                }
                _ => false,
            },
            Literal::DocComment(comment) => match other {
                Literal::String(other) => ctx.with_doc_comment(*comment, |v| v == other.to_str()),
                Literal::DocComment(other) => comment == other,
                _ => false,
            },
            _ => self == other,
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Token<'arena> {
    pub ty: TokenType,
    pub literal: Option<Literal<'arena>>,
    pub span: Span<'arena>,
}

impl<'arena> From<Token<'arena>> for Ident<'arena> {
    fn from(value: Token<'arena>) -> Self {
        assert_eq!(value.ty, TokenType::IdentifierLiteral);
        let Some(Literal::String(s)) = value.literal else {
            unreachable!("expected value.literal to be Some(Literal::String(_))")
        };
        Self::new(s, value.span)
    }
}

pub struct IdentDisplay<'a>(pub Symbol<'a>);
pub struct StrIdentDisplay<'a>(pub &'a str);

impl Display for StrIdentDisplay<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        display_ident(f, self.0)
    }
}
impl Display for IdentDisplay<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        display_ident(f, self.0.to_str())
    }
}

impl Display for TokenType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(s) = self.as_str() {
            if s.chars().all(|v| v.is_ascii_alphabetic()) {
                return f.write_str(s);
            }
            f.write_char('\'')?;
            f.write_str(s)?;
            return f.write_char('\'');
        }
        match self {
            TokenType::IdentifierLiteral => f.write_str("an identifier"),
            TokenType::SIntLiteral => f.write_str("a signed number"),
            TokenType::UIntLiteral => f.write_str("an unsigned number"),
            TokenType::VoidLiteral => f.write_str("void"),
            TokenType::FloatLiteral => f.write_str("a decimal number"),
            TokenType::StringLiteral => f.write_str("a string"),
            TokenType::BooleanLiteral => f.write_str("a boolean"),
            TokenType::MacroInvocation => f.write_str("a macro invocation"),
            _ => unreachable!(),
        }
    }
}

fn display_ident(f: &mut std::fmt::Formatter<'_>, ident: &str) -> std::fmt::Result {
    // only idents that are >= 1 character and only alphanumeric + #, $, _ and don't start with a
    // number can be printed without a string
    let needs_str = matches!(ident.chars().next(), Some('0'..='9') | None)
        || Lexer::try_token_from_keyword(ident).is_some()
        || ident
            .chars()
            .any(|c| !matches!(c, 'a'..='z'|'A'..='Z'|'0'..='9'|'#'|'$'|'_'));
    if needs_str {
        f.write_char('`')?;
        for c in ident.escape_debug() {
            f.write_char(c)?;
        }
        f.write_char('`')
    } else {
        f.write_str(ident)
    }
}

impl Display for Token<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.ty.as_str().is_some() {
            return Display::fmt(&self.ty, f);
        }
        match self.ty {
            TokenType::BooleanLiteral => match &self.literal {
                Some(Literal::Bool(v)) => Display::fmt(v, f),
                _ => f.write_str("bool(malformed data)"),
            },
            TokenType::IdentifierLiteral => match &self.literal {
                Some(Literal::String(v)) => display_ident(f, v),
                _ => f.write_str("identifier(malformed data)"),
            },
            TokenType::FloatLiteral => match self.literal {
                Some(Literal::Float(v, ty)) => f.write_fmt(format_args!("{v}{ty}")),
                _ => f.write_str("float(malformed data)"),
            },
            TokenType::SIntLiteral => match self.literal {
                Some(Literal::SInt(v, ty)) => f.write_fmt(format_args!("{v}{ty}")),
                _ => f.write_str("int(malformed data)"),
            },
            TokenType::UIntLiteral => match self.literal {
                Some(Literal::UInt(v, ty)) => f.write_fmt(format_args!("{v}{ty}")),
                _ => f.write_str("uint(malformed data)"),
            },
            TokenType::StringLiteral => match &self.literal {
                Some(Literal::String(v)) => Debug::fmt(v, f),
                _ => f.write_str("string(malformed data)"),
            },
            TokenType::ByteStringLiteral => match &self.literal {
                Some(Literal::ByteString(v)) => Debug::fmt(v, f),
                _ => f.write_str("string(malformed data)"),
            },
            TokenType::MacroInvocation => match &self.literal {
                Some(Literal::String(v)) => {
                    display_ident(f, v)?;
                    f.write_char('!')
                }
                _ => f.write_str("macro_invocation(malformed data)!"),
            },
            _ => unreachable!(),
        }
    }
}

impl<'arena> Token<'arena> {
    pub fn new(ty: TokenType, literal: Option<Literal<'arena>>, span: Span<'arena>) -> Self {
        Self { ty, span, literal }
    }

    pub fn void_literal(&self) {
        match &self.literal {
            None => (),
            _ => unreachable!("{self} should only ever contain a void literal"),
        }
    }

    pub fn string_literal(&self) -> Symbol<'arena> {
        match &self.literal {
            Some(Literal::String(v)) => *v,
            _ => unreachable!("{self} should only ever contain a string literal"),
        }
    }

    pub fn byte_string_literal(&self) -> ByteSymbol<'arena> {
        match &self.literal {
            Some(Literal::ByteString(v)) => *v,
            _ => unreachable!("{self} should only ever contain a string literal"),
        }
    }

    pub fn bool_literal(&self) -> bool {
        match &self.literal {
            Some(Literal::Bool(v)) => *v,
            _ => unreachable!("{self} should only ever contain a boolean literal"),
        }
    }

    pub fn float_literal(&self) -> (f64, NumberType) {
        match &self.literal {
            Some(Literal::Float(v, numty)) => (*v, *numty),
            _ => unreachable!("{self} should only ever contain a void literal"),
        }
    }

    pub fn sint_literal(&self) -> (i64, NumberType) {
        match &self.literal {
            Some(Literal::SInt(v, numty)) => (*v, *numty),
            _ => unreachable!("{self} should only ever contain a void literal"),
        }
    }

    pub fn uint_literal(&self) -> (u64, NumberType) {
        match &self.literal {
            Some(Literal::UInt(v, numty)) => (*v, *numty),
            _ => unreachable!("{self} should only ever contain a void literal"),
        }
    }

    pub fn doc_literal(&self) -> DocComment {
        match &self.literal {
            Some(Literal::DocComment(v)) => *v,
            _ => unreachable!("{self} should only ever contain a void literal"),
        }
    }
}
