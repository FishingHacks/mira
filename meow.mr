extern fn malloc(size: usize) -> &void;
extern fn realloc(ptr: &void, size: usize) -> &void;
extern fn free(ptr: &void);

@lang("allocator_trait")
trait Allocator {
    fn alloc(self: &Self, size: usize) -> &void;
    fn realloc(self: &Self, ptr: &void, size: usize) -> &void;
    fn free(self: &Self, ptr: &void);
}

struct CAlloc {;
    impl Allocator {
        fn alloc(self: &Self, size: usize) -> &void = malloc(size);
        fn realloc(self: &Self, ptr: &void, size: usize) -> &void = realloc(ptr, size);
        fn free(self: &Self, ptr: &void) = free(ptr);
    }
}
@lang("allocator")
let allocator: CAlloc = .{};

@lang("copy_trait")
trait Copy {}

@lang("clone_trait")
trait Clone {
    fn clone(self: &Self) -> Self;
}

@lang("printf")
@ext_vararg()
extern fn printf(pat: &u8);

@lang("u8")
struct u8_t {;
    fn max(self: u8, other: u8) -> u8 {
        if (self > other) return self;
        else return other;
    }

    fn min(self: u8, other: u8) -> u8 {
        if (self < other) return self;
        else return other;
    }
    fn clamp(self: u8, min: u8, max: u8) -> u8 = self.max(min).min(max);
    fn abs_diff(self: u8, other: u8) -> u8 {
        if (self < other) return other - self;
        else return self - other;
    }
    fn next_multiple_of(self: u8, other: u8) -> u8 {
        let r = self % other;
        if (r == 0) return self;
        else return self + (other - r);
    }
    fn is_ascii(self: u8) -> bool = self <= 127;
    fn cast_signed(self: u8) -> i8 = self as i8;
    fn print(self: u8) = printf("%d\n\0" as &u8, self as i32);
}

extern fn main(argc: usize, argv: &&u8) -> i32 {
    return 0;
}
